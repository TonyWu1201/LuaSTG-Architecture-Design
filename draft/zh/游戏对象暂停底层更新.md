# 设计草案：游戏对象禁用底层更新

## 背景
原先 GameObject 有 pause 属性来跳过速度的计算，但这一设计造成了许多不便，因此在更新游戏循环逻辑时将其移除。但是实际上游戏内还是有许多对于“部分时停”和“部分时缓”的需求（例如子弹的弹雾和一些效果的制作）。因此需要一个替换方案来解决此问题。

## 提案
通过给 GameObject 增加一个属性（例如: skip_objframe）来改变其更新行为。当 skip_objframe 为 true 时，不执行 GameObject 的底层更新但会执行frame回调以便增加更多的自定义性（例如被时停的敌人依然有一些额外需要特殊处理的行为）。下面通过伪代码简单说明:
1. 游戏对象更新到下一帧（伪代码）:  
    ```lua
    for object in lstg.ObjList() do
        -- 如果游戏对象是正常状态，执行更新，否则回收对象
        if object.status == "normal" then
            if not object.skip_objframe then
                -- 更新 dx、dy，注意 lastx、lasty 在 lua 层不可访问
                object.dx = object.x - object.lastx
                object.dy = object.y - object.lasty
                object.lastx = object.x
                object.lasty = object.y
                -- 更新计时器
                object.timer = object.timer + 1
                object.ani = object.ani + 1
            end
        else
            -- 回收对象
            freeGameObject(object)
        end
    end
    ```
2. 游戏对象更新（伪代码）：  
    ```lua
    for object in lstg.ObjList() do
        -- 执行 frame 回调函数
        object:frame()
    end
    for object in lstg.ObjList() do
        if not object.skip_objframe then
            -- 根据 ax、ay、ag 更新 vx、vy
            object.vx = object.vx + object.ax
            object.vy = object.vy + object.ay - object.ag
            -- 根据 maxv 限制 vx、vy
            local speed = sqrt(object.vx * object.vx + object.vy * object.vy)
            if speed > maxv then
                local scale = maxv / speed
                object.vx = object.vx * scale
                object.vy = object.vy * scale
            end
            -- 根据 maxvx、maxvy 限制 vx、vy 范围
            object.vx = clamp(object.vx, -object.maxvx, object.maxvx)
            object.vy = clamp(object.vy, -object.maxvy, object.maxvy)
            -- 根据 vx、vy 更新 x、y
            object.x = object.x + object.vx
            object.y = object.y + object.vy
            -- 根据 omega（omiga）更新 rot
            object.rot = object.rot + object.omega
            -- 根据 navi 更新 rot
            if object.navi then
                object.rot = atan2(object.dy, object.dx)
            end
            -- 更新粒子系统（若有）
            updateParticleSystem(object)
        end
    end
    ```
3. 相交检测（伪代码）：  
    ```lua
    -- 第一步
    local results = {}
    for object1 in lstg.ObjList(group1) do
        for object2 in lstg.ObjList(group2) do
            if hasIntersection(object1, object2) then
                table.insert(results, { object1, object2 })
            end
        end
    end
    -- 第二步
    for _, result in ipairs(results) do
        -- 执行属于第一个碰撞组的游戏对象的 colli 回调函数
        if not result[1].skip_objframe then
            result[1]:colli(result[2])
        end
    end
    ```

## 有待讨论的细节
* 部分属性的更新是否应该被跳过（例如dx dy），或者需要进行特殊处理
* 部分行为的更新是否应该被跳过（例如碰撞）